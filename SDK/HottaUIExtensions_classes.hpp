#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HottaUIExtensions

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "HottaUIExtensions_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class HottaUIExtensions.ScrollPhysics
// 0x0008 (0x0030 - 0x0028)
class UScrollPhysics : public UObject
{
public:
	class UScrollPhysics*                         Parent;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UScrollPhysics* CreateScrollPhysics(TSubclassOf<class UScrollPhysics> InClass, class UObject* InOuter, class UScrollPhysics* InParent);

	class UScrollPhysics* ApplyTo(class UScrollPhysics* InAncestor) const;
	const struct FSpringDescription GetSpring() const;
	const struct FTolerance GetTolerance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollPhysics">();
	}
	static class UScrollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollPhysics>();
	}
};
static_assert(alignof(UScrollPhysics) == 0x000008, "Wrong alignment on UScrollPhysics");
static_assert(sizeof(UScrollPhysics) == 0x000030, "Wrong size on UScrollPhysics");
static_assert(offsetof(UScrollPhysics, Parent) == 0x000028, "Member 'UScrollPhysics::Parent' has a wrong offset!");

// Class HottaUIExtensions.AlwaysScrollableScrollPhysics
// 0x0000 (0x0030 - 0x0030)
class UAlwaysScrollableScrollPhysics final : public UScrollPhysics
{
public:
	static class UAlwaysScrollableScrollPhysics* CreateAlwaysScrollableScrollPhysics(TSubclassOf<class UAlwaysScrollableScrollPhysics> InClass, class UObject* InOuter, class UScrollPhysics* InParent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysScrollableScrollPhysics">();
	}
	static class UAlwaysScrollableScrollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysScrollableScrollPhysics>();
	}
};
static_assert(alignof(UAlwaysScrollableScrollPhysics) == 0x000008, "Wrong alignment on UAlwaysScrollableScrollPhysics");
static_assert(sizeof(UAlwaysScrollableScrollPhysics) == 0x000030, "Wrong size on UAlwaysScrollableScrollPhysics");

// Class HottaUIExtensions.ScrollActivity
// 0x0008 (0x0030 - 0x0028)
class UScrollActivity : public UObject
{
public:
	class UScrollPosition*                        Position;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UScrollActivity* CreateScrollActivity(TSubclassOf<class UScrollActivity> InClass, class UScrollPosition* InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollActivity">();
	}
	static class UScrollActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollActivity>();
	}
};
static_assert(alignof(UScrollActivity) == 0x000008, "Wrong alignment on UScrollActivity");
static_assert(sizeof(UScrollActivity) == 0x000030, "Wrong size on UScrollActivity");
static_assert(offsetof(UScrollActivity, Position) == 0x000028, "Member 'UScrollActivity::Position' has a wrong offset!");

// Class HottaUIExtensions.BallisticScrollActivity
// 0x0018 (0x0048 - 0x0030)
class UBallisticScrollActivity final : public UScrollActivity
{
public:
	uint8                                         Pad_1158[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USimulation*                            Simulation;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1159[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBallisticScrollActivity* CreateBallisticScrollActivity(TSubclassOf<class UBallisticScrollActivity> InClass, class UScrollPosition* InPosition, class USimulation* InSimulation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BallisticScrollActivity">();
	}
	static class UBallisticScrollActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBallisticScrollActivity>();
	}
};
static_assert(alignof(UBallisticScrollActivity) == 0x000008, "Wrong alignment on UBallisticScrollActivity");
static_assert(sizeof(UBallisticScrollActivity) == 0x000048, "Wrong size on UBallisticScrollActivity");
static_assert(offsetof(UBallisticScrollActivity, Simulation) == 0x000038, "Member 'UBallisticScrollActivity::Simulation' has a wrong offset!");

// Class HottaUIExtensions.BouncingScrollPhysics
// 0x0000 (0x0030 - 0x0030)
class UBouncingScrollPhysics final : public UScrollPhysics
{
public:
	static class UBouncingScrollPhysics* CreateBouncingScrollPhysics(TSubclassOf<class UBouncingScrollPhysics> InClass, class UObject* InOuter, class UScrollPhysics* InParent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BouncingScrollPhysics">();
	}
	static class UBouncingScrollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBouncingScrollPhysics>();
	}
};
static_assert(alignof(UBouncingScrollPhysics) == 0x000008, "Wrong alignment on UBouncingScrollPhysics");
static_assert(sizeof(UBouncingScrollPhysics) == 0x000030, "Wrong size on UBouncingScrollPhysics");

// Class HottaUIExtensions.Simulation
// 0x0010 (0x0038 - 0x0028)
class USimulation : public UObject
{
public:
	uint8                                         Pad_115A[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USimulation* CreateSimulation(TSubclassOf<class USimulation> InClass, class UObject* InOuter, const struct FTolerance& InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Simulation">();
	}
	static class USimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimulation>();
	}
};
static_assert(alignof(USimulation) == 0x000008, "Wrong alignment on USimulation");
static_assert(sizeof(USimulation) == 0x000038, "Wrong size on USimulation");

// Class HottaUIExtensions.BouncingScrollSimulation
// 0x0030 (0x0068 - 0x0038)
class UBouncingScrollSimulation final : public USimulation
{
public:
	uint8                                         Pad_115C[0x20];                                    // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USimulation*                            SpringSimulation;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrictionSimulation*                    FrictionSimulation;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UBouncingScrollSimulation* CreateBouncingScrollSimulation(TSubclassOf<class UBouncingScrollSimulation> InClass, class UObject* InOuter, const float InPosition, const float InVelocity, const float InLeadingExtent, const float InTrailingExtent, const struct FSpringDescription& InSpring, const struct FTolerance& InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BouncingScrollSimulation">();
	}
	static class UBouncingScrollSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBouncingScrollSimulation>();
	}
};
static_assert(alignof(UBouncingScrollSimulation) == 0x000008, "Wrong alignment on UBouncingScrollSimulation");
static_assert(sizeof(UBouncingScrollSimulation) == 0x000068, "Wrong size on UBouncingScrollSimulation");
static_assert(offsetof(UBouncingScrollSimulation, SpringSimulation) == 0x000058, "Member 'UBouncingScrollSimulation::SpringSimulation' has a wrong offset!");
static_assert(offsetof(UBouncingScrollSimulation, FrictionSimulation) == 0x000060, "Member 'UBouncingScrollSimulation::FrictionSimulation' has a wrong offset!");

// Class HottaUIExtensions.ClampingScrollPhysics
// 0x0000 (0x0030 - 0x0030)
class UClampingScrollPhysics final : public UScrollPhysics
{
public:
	static class UClampingScrollPhysics* CreateClampingScrollPhysics(TSubclassOf<class UClampingScrollPhysics> InClass, class UObject* InOuter, class UScrollPhysics* InParent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClampingScrollPhysics">();
	}
	static class UClampingScrollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClampingScrollPhysics>();
	}
};
static_assert(alignof(UClampingScrollPhysics) == 0x000008, "Wrong alignment on UClampingScrollPhysics");
static_assert(sizeof(UClampingScrollPhysics) == 0x000030, "Wrong size on UClampingScrollPhysics");

// Class HottaUIExtensions.ClampingScrollSimulation
// 0x0018 (0x0050 - 0x0038)
class UClampingScrollSimulation final : public USimulation
{
public:
	uint8                                         Pad_115D[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClampingScrollSimulation* CreateClampingScrollSimulation(TSubclassOf<class UClampingScrollSimulation> InClass, class UObject* InOuter, const float InPosition, const float InVelocity, const struct FTolerance& InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClampingScrollSimulation">();
	}
	static class UClampingScrollSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClampingScrollSimulation>();
	}
};
static_assert(alignof(UClampingScrollSimulation) == 0x000008, "Wrong alignment on UClampingScrollSimulation");
static_assert(sizeof(UClampingScrollSimulation) == 0x000050, "Wrong size on UClampingScrollSimulation");

// Class HottaUIExtensions.DragScrollActivity
// 0x0018 (0x0048 - 0x0030)
class UDragScrollActivity final : public UScrollActivity
{
public:
	uint8                                         Pad_115F[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDragScrollActivity* CreateDragScrollActivity(TSubclassOf<class UDragScrollActivity> InClass, class UScrollPosition* InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragScrollActivity">();
	}
	static class UDragScrollActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragScrollActivity>();
	}
};
static_assert(alignof(UDragScrollActivity) == 0x000008, "Wrong alignment on UDragScrollActivity");
static_assert(sizeof(UDragScrollActivity) == 0x000048, "Wrong size on UDragScrollActivity");

// Class HottaUIExtensions.DrivenScrollActivity
// 0x0028 (0x0058 - 0x0030)
class UDrivenScrollActivity final : public UScrollActivity
{
public:
	uint8                                         Pad_1160[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1161[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDrivenScrollActivity* CreateDrivenScrollActivity(TSubclassOf<class UDrivenScrollActivity> InClass, class UScrollPosition* InPosition, const float InFrom, const float InTo, const float InDuration, class UCurveFloat* InCurve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrivenScrollActivity">();
	}
	static class UDrivenScrollActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrivenScrollActivity>();
	}
};
static_assert(alignof(UDrivenScrollActivity) == 0x000008, "Wrong alignment on UDrivenScrollActivity");
static_assert(sizeof(UDrivenScrollActivity) == 0x000058, "Wrong size on UDrivenScrollActivity");
static_assert(offsetof(UDrivenScrollActivity, Curve) == 0x000048, "Member 'UDrivenScrollActivity::Curve' has a wrong offset!");

// Class HottaUIExtensions.FixedExtentScrollableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IFixedExtentScrollableObjectInterface final : public IInterface
{
public:
	float Interface_GetItemExtent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedExtentScrollableObjectInterface">();
	}
	static class IFixedExtentScrollableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFixedExtentScrollableObjectInterface>();
	}
};
static_assert(alignof(IFixedExtentScrollableObjectInterface) == 0x000008, "Wrong alignment on IFixedExtentScrollableObjectInterface");
static_assert(sizeof(IFixedExtentScrollableObjectInterface) == 0x000028, "Wrong size on IFixedExtentScrollableObjectInterface");

// Class HottaUIExtensions.ScrollableState
// 0x0040 (0x0068 - 0x0028)
class UScrollableState : public UObject
{
public:
	uint8                                         Pad_1163[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollController*                      Controller;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollPosition*                        Position;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollPhysics*                         Physics;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollContext*                         Context;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoldScrollActivity*                    HoldScrollActivity;                                // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragScrollActivity*                    DragScrollActivity;                                // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1164[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UScrollableState* CreateScrollState(TSubclassOf<class UScrollableState> InClass, class UScrollContext* InContext);

	void UpdateScrollExtent(class UScrollContext* InContext);
	void UpdateViewportDimension(class UScrollContext* InContext);

	class UScrollController* GetController() const;
	EScrollDirectionType GetDirection() const;
	class UScrollPhysics* GetPhysics() const;
	class UScrollPosition* GetPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollableState">();
	}
	static class UScrollableState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollableState>();
	}
};
static_assert(alignof(UScrollableState) == 0x000008, "Wrong alignment on UScrollableState");
static_assert(sizeof(UScrollableState) == 0x000068, "Wrong size on UScrollableState");
static_assert(offsetof(UScrollableState, Controller) == 0x000030, "Member 'UScrollableState::Controller' has a wrong offset!");
static_assert(offsetof(UScrollableState, Position) == 0x000038, "Member 'UScrollableState::Position' has a wrong offset!");
static_assert(offsetof(UScrollableState, Physics) == 0x000040, "Member 'UScrollableState::Physics' has a wrong offset!");
static_assert(offsetof(UScrollableState, Context) == 0x000048, "Member 'UScrollableState::Context' has a wrong offset!");
static_assert(offsetof(UScrollableState, HoldScrollActivity) == 0x000050, "Member 'UScrollableState::HoldScrollActivity' has a wrong offset!");
static_assert(offsetof(UScrollableState, DragScrollActivity) == 0x000058, "Member 'UScrollableState::DragScrollActivity' has a wrong offset!");

// Class HottaUIExtensions.FixedExtentScrollableState
// 0x0000 (0x0068 - 0x0068)
class UFixedExtentScrollableState final : public UScrollableState
{
public:
	static class UFixedExtentScrollableState* CreateFixedExtentScrollableState(TSubclassOf<class UFixedExtentScrollableState> InClass, class UScrollContext* InContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedExtentScrollableState">();
	}
	static class UFixedExtentScrollableState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedExtentScrollableState>();
	}
};
static_assert(alignof(UFixedExtentScrollableState) == 0x000008, "Wrong alignment on UFixedExtentScrollableState");
static_assert(sizeof(UFixedExtentScrollableState) == 0x000068, "Wrong size on UFixedExtentScrollableState");

// Class HottaUIExtensions.ScrollContext
// 0x0048 (0x0070 - 0x0028)
class UScrollContext : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnScrollExtentUpdateNotification;                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewportDimensionUpdateNotification;             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UScrollPhysics*                         Physics;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollController*                      Controller;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1165[0x10];                                    // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollableState*                       State;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UScrollContext* CreateScrollContext(TSubclassOf<class UScrollContext> InClass, class UObject* InOuter);

	void OnScrollExtentUpdateNotification__DelegateSignature(class UScrollContext* InContext);
	void OnViewportDimensionUpdateNotification__DelegateSignature(class UScrollContext* InContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollContext">();
	}
	static class UScrollContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollContext>();
	}
};
static_assert(alignof(UScrollContext) == 0x000008, "Wrong alignment on UScrollContext");
static_assert(sizeof(UScrollContext) == 0x000070, "Wrong size on UScrollContext");
static_assert(offsetof(UScrollContext, OnScrollExtentUpdateNotification) == 0x000028, "Member 'UScrollContext::OnScrollExtentUpdateNotification' has a wrong offset!");
static_assert(offsetof(UScrollContext, OnViewportDimensionUpdateNotification) == 0x000038, "Member 'UScrollContext::OnViewportDimensionUpdateNotification' has a wrong offset!");
static_assert(offsetof(UScrollContext, Physics) == 0x000048, "Member 'UScrollContext::Physics' has a wrong offset!");
static_assert(offsetof(UScrollContext, Controller) == 0x000050, "Member 'UScrollContext::Controller' has a wrong offset!");
static_assert(offsetof(UScrollContext, State) == 0x000068, "Member 'UScrollContext::State' has a wrong offset!");

// Class HottaUIExtensions.FixedExtentScrollContext
// 0x0008 (0x0078 - 0x0070)
class UFixedExtentScrollContext final : public UScrollContext
{
public:
	uint8                                         Pad_1166[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFixedExtentScrollContext* CreateFixedExtentScrollContext(TSubclassOf<class UFixedExtentScrollContext> InClass, class UObject* InOuter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedExtentScrollContext">();
	}
	static class UFixedExtentScrollContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedExtentScrollContext>();
	}
};
static_assert(alignof(UFixedExtentScrollContext) == 0x000008, "Wrong alignment on UFixedExtentScrollContext");
static_assert(sizeof(UFixedExtentScrollContext) == 0x000078, "Wrong size on UFixedExtentScrollContext");

// Class HottaUIExtensions.ScrollController
// 0x0018 (0x0040 - 0x0028)
class UScrollController : public UObject
{
public:
	float                                         InitialScrollOffset;                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1167[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UScrollPosition*>                Positions;                                         // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UScrollController* CreateScrollController(TSubclassOf<class UScrollController> InClass, class UObject* InOuter, const float Param_InitialScrollOffset);

	bool AnimateTo(const float InNewScrollOffset, const float InDuration, class UCurveFloat* InCurve);
	void Attach(class UScrollPosition* InPosition);
	class UScrollPosition* CreateScrollPosition(TSubclassOf<class UScrollPosition> InClass, class UScrollableState* InState, class UScrollPhysics* InPhysics);
	void Detach(class UScrollPosition* InPosition);
	class UScrollPosition* GetPosition();
	TArray<class UScrollPosition*> GetPositions();
	void JumpTo(const float InNewScrollOffset);

	float GetInitialScrollOffset() const;
	float GetScrollOffset() const;
	bool HasClients() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollController">();
	}
	static class UScrollController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollController>();
	}
};
static_assert(alignof(UScrollController) == 0x000008, "Wrong alignment on UScrollController");
static_assert(sizeof(UScrollController) == 0x000040, "Wrong size on UScrollController");
static_assert(offsetof(UScrollController, InitialScrollOffset) == 0x000028, "Member 'UScrollController::InitialScrollOffset' has a wrong offset!");
static_assert(offsetof(UScrollController, Positions) == 0x000030, "Member 'UScrollController::Positions' has a wrong offset!");

// Class HottaUIExtensions.FixedExtentScrollController
// 0x0008 (0x0048 - 0x0040)
class UFixedExtentScrollController final : public UScrollController
{
public:
	uint8                                         Pad_116A[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFixedExtentScrollController* CreateFixedExtentScrollController(TSubclassOf<class UFixedExtentScrollController> InClass, class UObject* InOuter, const int32 InitialItem);

	bool AnimateToItem(const int32 InTargetItemIndex);
	bool JumpToItem(const int32 InTargetItemIndex);

	int32 GetSelectedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedExtentScrollController">();
	}
	static class UFixedExtentScrollController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedExtentScrollController>();
	}
};
static_assert(alignof(UFixedExtentScrollController) == 0x000008, "Wrong alignment on UFixedExtentScrollController");
static_assert(sizeof(UFixedExtentScrollController) == 0x000048, "Wrong size on UFixedExtentScrollController");

// Class HottaUIExtensions.FixedExtentScrollPhysics
// 0x0000 (0x0030 - 0x0030)
class UFixedExtentScrollPhysics final : public UScrollPhysics
{
public:
	static class UFixedExtentScrollPhysics* CreateFixedExtentScrollPhysics(TSubclassOf<class UFixedExtentScrollPhysics> InClass, class UObject* InOuter, class UScrollPhysics* InParent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedExtentScrollPhysics">();
	}
	static class UFixedExtentScrollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedExtentScrollPhysics>();
	}
};
static_assert(alignof(UFixedExtentScrollPhysics) == 0x000008, "Wrong alignment on UFixedExtentScrollPhysics");
static_assert(sizeof(UFixedExtentScrollPhysics) == 0x000030, "Wrong size on UFixedExtentScrollPhysics");

// Class HottaUIExtensions.ScrollPosition
// 0x0088 (0x00B0 - 0x0028)
class UScrollPosition : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnScrollStartNotification;                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScrollUpdateNotification;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScrollEndNotification;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScrollOffsetChangedEvent;                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverscrollNotification;                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnContentDimensionsUpdateNotification;             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UScrollableState*                       State;                                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollPhysics*                         Physics;                                           // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollActivity*                        CurrentScrollActivity;                             // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116E[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UScrollPosition* CreateScrollPosition(TSubclassOf<class UScrollPosition> InClass, class UScrollableState* InState, class UScrollPhysics* InPhysics, const float InitialScrollOffset);

	void AnimateTo(const float InNewScrollOffset, const float InDuration, class UCurveFloat* InCurve);
	void ApplyUserOffset(const float InDeltaOffset);
	bool BeginActivity(class UScrollActivity* InNewScrollActivity);
	void CorrectScrollOffset(const float InNewScrollOffset);
	class UDragScrollActivity* Drag();
	void GoBallistic(const float InVelocity);
	class UIdleScrollActivity* GoIdle();
	class UHoldScrollActivity* Hold();
	void JumpTo(const float InNewScrollOffset);
	void MoveTo(const float InNewScrollOffset, const float InDuration, class UCurveFloat* InCurve);
	void OnContentDimensionsUpdateNotification__DelegateSignature(class UScrollPosition* InScrollPosition, float InOldMinScrollExtent, float InOldMaxScrollExtent, float InOldScrollOffset, float InMinScrollExtent, float InMaxScrollExtent, float InScrollOffset);
	void OnOverscrollNotification__DelegateSignature(class UScrollPosition* InScrollPosition, float InOverscroll);
	void OnScrollEndNotification__DelegateSignature(class UScrollPosition* InScrollPosition);
	void OnScrollOffsetChangedEvent__DelegateSignature(class UScrollPosition* InScrollPosition, float InOldScrollOffset, float InScrollOffset);
	void OnScrollStartNotification__DelegateSignature(class UScrollPosition* InScrollPosition);
	void OnScrollUpdateNotification__DelegateSignature(class UScrollPosition* InScrollPosition, float InDeltaScrollOffset);
	float SetScrollOffset(const float InNewScrollOffset);

	bool CheckScrollOffsetOutOfRange(const float InScrollOffset) const;
	float GetMaxScrollExtent() const;
	float GetMinScrollExtent() const;
	EScrollDirectionType GetScrollDirection() const;
	float GetScrollOffset() const;
	struct FFloatRange GetScrollRange() const;
	float GetScrollVelocity() const;
	float GetViewportDimension() const;
	bool HasContentDimensions() const;
	bool HasViewportDimension() const;
	bool IsOutOfRange() const;
	bool IsScrolling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollPosition">();
	}
	static class UScrollPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollPosition>();
	}
};
static_assert(alignof(UScrollPosition) == 0x000008, "Wrong alignment on UScrollPosition");
static_assert(sizeof(UScrollPosition) == 0x0000B0, "Wrong size on UScrollPosition");
static_assert(offsetof(UScrollPosition, OnScrollStartNotification) == 0x000028, "Member 'UScrollPosition::OnScrollStartNotification' has a wrong offset!");
static_assert(offsetof(UScrollPosition, OnScrollUpdateNotification) == 0x000038, "Member 'UScrollPosition::OnScrollUpdateNotification' has a wrong offset!");
static_assert(offsetof(UScrollPosition, OnScrollEndNotification) == 0x000048, "Member 'UScrollPosition::OnScrollEndNotification' has a wrong offset!");
static_assert(offsetof(UScrollPosition, OnScrollOffsetChangedEvent) == 0x000058, "Member 'UScrollPosition::OnScrollOffsetChangedEvent' has a wrong offset!");
static_assert(offsetof(UScrollPosition, OnOverscrollNotification) == 0x000068, "Member 'UScrollPosition::OnOverscrollNotification' has a wrong offset!");
static_assert(offsetof(UScrollPosition, OnContentDimensionsUpdateNotification) == 0x000078, "Member 'UScrollPosition::OnContentDimensionsUpdateNotification' has a wrong offset!");
static_assert(offsetof(UScrollPosition, State) == 0x000088, "Member 'UScrollPosition::State' has a wrong offset!");
static_assert(offsetof(UScrollPosition, Physics) == 0x000090, "Member 'UScrollPosition::Physics' has a wrong offset!");
static_assert(offsetof(UScrollPosition, CurrentScrollActivity) == 0x000098, "Member 'UScrollPosition::CurrentScrollActivity' has a wrong offset!");

// Class HottaUIExtensions.FixedExtentScrollPosition
// 0x0000 (0x00B0 - 0x00B0)
class UFixedExtentScrollPosition final : public UScrollPosition
{
public:
	static class UFixedExtentScrollPosition* CreateFixedExtentScrollPosition(TSubclassOf<class UFixedExtentScrollPosition> InClass, class UFixedExtentScrollableState* InState, class UScrollPhysics* InPhysics, const int32 InitialItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedExtentScrollPosition">();
	}
	static class UFixedExtentScrollPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedExtentScrollPosition>();
	}
};
static_assert(alignof(UFixedExtentScrollPosition) == 0x000008, "Wrong alignment on UFixedExtentScrollPosition");
static_assert(sizeof(UFixedExtentScrollPosition) == 0x0000B0, "Wrong size on UFixedExtentScrollPosition");

// Class HottaUIExtensions.FrictionSimulation
// 0x0010 (0x0048 - 0x0038)
class UFrictionSimulation : public USimulation
{
public:
	uint8                                         Pad_1175[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFrictionSimulation* CreateFrictionSimulation(TSubclassOf<class UFrictionSimulation> InClass, class UObject* InOuter, const float InDrag, const float InPosition, const float InVelocity, const struct FTolerance& InTolerance);
	static class UFrictionSimulation* Through(TSubclassOf<class UFrictionSimulation> InClass, class UObject* InOuter, const float InStartPosition, const float InEndPosition, const float InStartVelocity, const float InEndVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrictionSimulation">();
	}
	static class UFrictionSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrictionSimulation>();
	}
};
static_assert(alignof(UFrictionSimulation) == 0x000008, "Wrong alignment on UFrictionSimulation");
static_assert(sizeof(UFrictionSimulation) == 0x000048, "Wrong size on UFrictionSimulation");

// Class HottaUIExtensions.BoundedFrictionSimulation
// 0x0008 (0x0050 - 0x0048)
class UBoundedFrictionSimulation final : public UFrictionSimulation
{
public:
	uint8                                         Pad_1176[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBoundedFrictionSimulation* CreateBoundedFrictionSimulation(TSubclassOf<class UBoundedFrictionSimulation> InClass, class UObject* InOuter, const float InDrag, const float InPosition, const float InVelocity, const float InMinX, const float InMaxX, const struct FTolerance& InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoundedFrictionSimulation">();
	}
	static class UBoundedFrictionSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoundedFrictionSimulation>();
	}
};
static_assert(alignof(UBoundedFrictionSimulation) == 0x000008, "Wrong alignment on UBoundedFrictionSimulation");
static_assert(sizeof(UBoundedFrictionSimulation) == 0x000050, "Wrong size on UBoundedFrictionSimulation");

// Class HottaUIExtensions.GravitySimulation
// 0x0010 (0x0048 - 0x0038)
class UGravitySimulation final : public USimulation
{
public:
	uint8                                         Pad_1177[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGravitySimulation* Create(class UObject* InOuter, const float InAcceleration, const float InDistance, const float InVelocity, const float InEndDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GravitySimulation">();
	}
	static class UGravitySimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGravitySimulation>();
	}
};
static_assert(alignof(UGravitySimulation) == 0x000008, "Wrong alignment on UGravitySimulation");
static_assert(sizeof(UGravitySimulation) == 0x000048, "Wrong size on UGravitySimulation");

// Class HottaUIExtensions.HoldScrollActivity
// 0x0000 (0x0030 - 0x0030)
class UHoldScrollActivity final : public UScrollActivity
{
public:
	static class UHoldScrollActivity* CreateHoldScrollActivity(TSubclassOf<class UHoldScrollActivity> InClass, class UScrollPosition* InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldScrollActivity">();
	}
	static class UHoldScrollActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldScrollActivity>();
	}
};
static_assert(alignof(UHoldScrollActivity) == 0x000008, "Wrong alignment on UHoldScrollActivity");
static_assert(sizeof(UHoldScrollActivity) == 0x000030, "Wrong size on UHoldScrollActivity");

// Class HottaUIExtensions.IdleScrollActivity
// 0x0000 (0x0030 - 0x0030)
class UIdleScrollActivity final : public UScrollActivity
{
public:
	static class UIdleScrollActivity* CreateIdleScrollActivity(TSubclassOf<class UIdleScrollActivity> InClass, class UScrollPosition* InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdleScrollActivity">();
	}
	static class UIdleScrollActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdleScrollActivity>();
	}
};
static_assert(alignof(UIdleScrollActivity) == 0x000008, "Wrong alignment on UIdleScrollActivity");
static_assert(sizeof(UIdleScrollActivity) == 0x000030, "Wrong size on UIdleScrollActivity");

// Class HottaUIExtensions.NeverScrollableScrollPhysics
// 0x0000 (0x0030 - 0x0030)
class UNeverScrollableScrollPhysics final : public UScrollPhysics
{
public:
	static class UNeverScrollableScrollPhysics* CreateNeverScrollableScrollPhysics(TSubclassOf<class UNeverScrollableScrollPhysics> InClass, class UObject* InOuter, class UScrollPhysics* InParent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeverScrollableScrollPhysics">();
	}
	static class UNeverScrollableScrollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeverScrollableScrollPhysics>();
	}
};
static_assert(alignof(UNeverScrollableScrollPhysics) == 0x000008, "Wrong alignment on UNeverScrollableScrollPhysics");
static_assert(sizeof(UNeverScrollableScrollPhysics) == 0x000030, "Wrong size on UNeverScrollableScrollPhysics");

// Class HottaUIExtensions.ScrollableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IScrollableObjectInterface final : public IInterface
{
public:
	class UScrollController* Interface_CreateScrollController();
	class UScrollPhysics* Interface_CreateScrollPhysics();

	float Interface_GetMaxScrollExtent() const;
	float Interface_GetMinScrollExtent() const;
	EScrollDirectionType Interface_GetScrollDirection() const;
	float Interface_GetViewportDimension() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollableObjectInterface">();
	}
	static class IScrollableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScrollableObjectInterface>();
	}
};
static_assert(alignof(IScrollableObjectInterface) == 0x000008, "Wrong alignment on IScrollableObjectInterface");
static_assert(sizeof(IScrollableObjectInterface) == 0x000028, "Wrong size on IScrollableObjectInterface");

// Class HottaUIExtensions.ScrollerLibrary
// 0x0000 (0x0028 - 0x0028)
class UScrollerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollerLibrary">();
	}
	static class UScrollerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollerLibrary>();
	}
};
static_assert(alignof(UScrollerLibrary) == 0x000008, "Wrong alignment on UScrollerLibrary");
static_assert(sizeof(UScrollerLibrary) == 0x000028, "Wrong size on UScrollerLibrary");

// Class HottaUIExtensions.SpringDescriptionLibrary
// 0x0000 (0x0028 - 0x0028)
class USpringDescriptionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FSpringDescription MakeSpringDescriptionWithDampingRatio(const float InMass, const float InStiffness, const float InRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringDescriptionLibrary">();
	}
	static class USpringDescriptionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringDescriptionLibrary>();
	}
};
static_assert(alignof(USpringDescriptionLibrary) == 0x000008, "Wrong alignment on USpringDescriptionLibrary");
static_assert(sizeof(USpringDescriptionLibrary) == 0x000028, "Wrong size on USpringDescriptionLibrary");

// Class HottaUIExtensions.SpringSimulation
// 0x0018 (0x0050 - 0x0038)
class USpringSimulation : public USimulation
{
public:
	uint8                                         Pad_1178[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USpringSimulation* CreateSpringSimulation(TSubclassOf<class USpringSimulation> InClass, class UObject* InOuter, const struct FSpringDescription& InSpring, const float InStart, const float InEnd, const float InVelocity, const struct FTolerance& InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringSimulation">();
	}
	static class USpringSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringSimulation>();
	}
};
static_assert(alignof(USpringSimulation) == 0x000008, "Wrong alignment on USpringSimulation");
static_assert(sizeof(USpringSimulation) == 0x000050, "Wrong size on USpringSimulation");

// Class HottaUIExtensions.ScrollSpringSimulation
// 0x0000 (0x0050 - 0x0050)
class UScrollSpringSimulation final : public USpringSimulation
{
public:
	static class UScrollSpringSimulation* CreateScrollSpringSimulation(TSubclassOf<class UScrollSpringSimulation> InClass, class UObject* InOuter, const struct FSpringDescription& InSpring, const float InStart, const float InEnd, const float InVelocity, const struct FTolerance& InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollSpringSimulation">();
	}
	static class UScrollSpringSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollSpringSimulation>();
	}
};
static_assert(alignof(UScrollSpringSimulation) == 0x000008, "Wrong alignment on UScrollSpringSimulation");
static_assert(sizeof(UScrollSpringSimulation) == 0x000050, "Wrong size on UScrollSpringSimulation");

// Class HottaUIExtensions.UIView
// 0x0018 (0x0158 - 0x0140)
class UUIView : public UPanelWidget
{
public:
	uint8                                         Pad_117B[0x18];                                    // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PrintDebugString(const class FString& InDebugString);

	void CollectChildrenInfo(int32* OutChildrenNum, TArray<ESlateVisibility>* OutChildrenVisibility, TArray<int32>* OutCollapsedChildIndexArray, TMap<int32, int32>* OutChildIndexToLayoutIndexMap) const;
	int32 GetLayoutChildrenNum() const;
	bool IsDebugMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIView">();
	}
	static class UUIView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIView>();
	}
};
static_assert(alignof(UUIView) == 0x000008, "Wrong alignment on UUIView");
static_assert(sizeof(UUIView) == 0x000158, "Wrong size on UUIView");

// Class HottaUIExtensions.UICircleView
// 0x0098 (0x01F0 - 0x0158)
class UUICircleView : public UUIView
{
public:
	float                                         Radius;                                            // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainAxisDegree;                                    // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeSize;                                         // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChildWidgetAngleFixed;                            // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackgroundAngleFixed;                             // 0x0165(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_117D[0x2];                                     // 0x0166(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BackgroundSlateBrush;                              // 0x0168(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	bool GetChildWidgetAngle(const int32 InChildIndex, float* OutAngle, const EUnit InAngleUnits) const;
	float GetChildWidgetIntervalAngle(const EUnit InAngleUnits) const;
	float GetRealBeginAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICircleView">();
	}
	static class UUICircleView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICircleView>();
	}
};
static_assert(alignof(UUICircleView) == 0x000008, "Wrong alignment on UUICircleView");
static_assert(sizeof(UUICircleView) == 0x0001F0, "Wrong size on UUICircleView");
static_assert(offsetof(UUICircleView, Radius) == 0x000158, "Member 'UUICircleView::Radius' has a wrong offset!");
static_assert(offsetof(UUICircleView, MainAxisDegree) == 0x00015C, "Member 'UUICircleView::MainAxisDegree' has a wrong offset!");
static_assert(offsetof(UUICircleView, RangeSize) == 0x000160, "Member 'UUICircleView::RangeSize' has a wrong offset!");
static_assert(offsetof(UUICircleView, bChildWidgetAngleFixed) == 0x000164, "Member 'UUICircleView::bChildWidgetAngleFixed' has a wrong offset!");
static_assert(offsetof(UUICircleView, bBackgroundAngleFixed) == 0x000165, "Member 'UUICircleView::bBackgroundAngleFixed' has a wrong offset!");
static_assert(offsetof(UUICircleView, BackgroundSlateBrush) == 0x000168, "Member 'UUICircleView::BackgroundSlateBrush' has a wrong offset!");

// Class HottaUIExtensions.UIViewSlot
// 0x0018 (0x0050 - 0x0038)
class UUIViewSlot : public UPanelSlot
{
public:
	bool                                          bAutoSize;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1180[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1181[0xC];                                     // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoSize(const bool bInAutoSize);
	void SetSize(const struct FVector2D& InSize);

	bool GetAutoSize() const;
	const struct FVector2D GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIViewSlot">();
	}
	static class UUIViewSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIViewSlot>();
	}
};
static_assert(alignof(UUIViewSlot) == 0x000008, "Wrong alignment on UUIViewSlot");
static_assert(sizeof(UUIViewSlot) == 0x000050, "Wrong size on UUIViewSlot");
static_assert(offsetof(UUIViewSlot, bAutoSize) == 0x000038, "Member 'UUIViewSlot::bAutoSize' has a wrong offset!");
static_assert(offsetof(UUIViewSlot, Size) == 0x00003C, "Member 'UUIViewSlot::Size' has a wrong offset!");

// Class HottaUIExtensions.UICircleViewSlot
// 0x0000 (0x0050 - 0x0050)
class UUICircleViewSlot final : public UUIViewSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICircleViewSlot">();
	}
	static class UUICircleViewSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICircleViewSlot>();
	}
};
static_assert(alignof(UUICircleViewSlot) == 0x000008, "Wrong alignment on UUICircleViewSlot");
static_assert(sizeof(UUICircleViewSlot) == 0x000050, "Wrong size on UUICircleViewSlot");

// Class HottaUIExtensions.UIScrollableCircleView
// 0x0040 (0x0230 - 0x01F0)
class UUIScrollableCircleView final : public UUICircleView
{
public:
	uint8                                         Pad_1182[0x10];                                    // 0x01F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollOffset;                                      // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScrollExtent;                                   // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScrollExtent;                                   // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1183[0x4];                                     // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFixedExtentScrollContext*              ScrollContext;                                     // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFixedExtentScrollableState*            ScrollableState;                                   // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1184[0x10];                                    // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollPositionOffsetChanged(class UScrollPosition* InScrollPosition, float InOldScrollOffset, float InScrollOffset);

	class UFixedExtentScrollableState* GetScrollableState() const;
	class UScrollController* GetScrollController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollableCircleView">();
	}
	static class UUIScrollableCircleView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollableCircleView>();
	}
};
static_assert(alignof(UUIScrollableCircleView) == 0x000008, "Wrong alignment on UUIScrollableCircleView");
static_assert(sizeof(UUIScrollableCircleView) == 0x000230, "Wrong size on UUIScrollableCircleView");
static_assert(offsetof(UUIScrollableCircleView, ScrollOffset) == 0x000200, "Member 'UUIScrollableCircleView::ScrollOffset' has a wrong offset!");
static_assert(offsetof(UUIScrollableCircleView, MinScrollExtent) == 0x000204, "Member 'UUIScrollableCircleView::MinScrollExtent' has a wrong offset!");
static_assert(offsetof(UUIScrollableCircleView, MaxScrollExtent) == 0x000208, "Member 'UUIScrollableCircleView::MaxScrollExtent' has a wrong offset!");
static_assert(offsetof(UUIScrollableCircleView, ScrollContext) == 0x000210, "Member 'UUIScrollableCircleView::ScrollContext' has a wrong offset!");
static_assert(offsetof(UUIScrollableCircleView, ScrollableState) == 0x000218, "Member 'UUIScrollableCircleView::ScrollableState' has a wrong offset!");

// Class HottaUIExtensions.UIScrollView
// 0x0038 (0x0190 - 0x0158)
class UUIScrollView final : public UUIView
{
public:
	uint8                                         Pad_1185[0x10];                                    // 0x0158(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EScrollDirectionType                          ScrollDirection;                                   // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1186[0x3];                                     // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollOffset;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFixedExtentScrollContext*              ScrollContext;                                     // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFixedExtentScrollableState*            ScrollableState;                                   // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1187[0x10];                                    // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollPositionOffsetChanged(class UScrollPosition* InScrollPosition, float InOldScrollOffset, float InScrollOffset);

	EScrollDirectionType GetScrollDirection() const;
	float GetScrollOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollView">();
	}
	static class UUIScrollView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollView>();
	}
};
static_assert(alignof(UUIScrollView) == 0x000008, "Wrong alignment on UUIScrollView");
static_assert(sizeof(UUIScrollView) == 0x000190, "Wrong size on UUIScrollView");
static_assert(offsetof(UUIScrollView, ScrollDirection) == 0x000168, "Member 'UUIScrollView::ScrollDirection' has a wrong offset!");
static_assert(offsetof(UUIScrollView, ScrollOffset) == 0x00016C, "Member 'UUIScrollView::ScrollOffset' has a wrong offset!");
static_assert(offsetof(UUIScrollView, ScrollContext) == 0x000170, "Member 'UUIScrollView::ScrollContext' has a wrong offset!");
static_assert(offsetof(UUIScrollView, ScrollableState) == 0x000178, "Member 'UUIScrollView::ScrollableState' has a wrong offset!");

// Class HottaUIExtensions.UIScrollViewSlot
// 0x0010 (0x0060 - 0x0050)
class UUIScrollViewSlot final : public UUIViewSlot
{
public:
	struct FMargin                                Margin;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	void SetMargin(const struct FMargin& InMargin);

	const struct FMargin GetMargin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewSlot">();
	}
	static class UUIScrollViewSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewSlot>();
	}
};
static_assert(alignof(UUIScrollViewSlot) == 0x000008, "Wrong alignment on UUIScrollViewSlot");
static_assert(sizeof(UUIScrollViewSlot) == 0x000060, "Wrong size on UUIScrollViewSlot");
static_assert(offsetof(UUIScrollViewSlot, Margin) == 0x000050, "Member 'UUIScrollViewSlot::Margin' has a wrong offset!");

// Class HottaUIExtensions.ViewEventProcessor
// 0x0000 (0x0028 - 0x0028)
class UViewEventProcessor : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewEventProcessor">();
	}
	static class UViewEventProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewEventProcessor>();
	}
};
static_assert(alignof(UViewEventProcessor) == 0x000008, "Wrong alignment on UViewEventProcessor");
static_assert(sizeof(UViewEventProcessor) == 0x000028, "Wrong size on UViewEventProcessor");

// Class HottaUIExtensions.ViewCircleScrollEventProcessor
// 0x0000 (0x0028 - 0x0028)
class UViewCircleScrollEventProcessor final : public UViewEventProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewCircleScrollEventProcessor">();
	}
	static class UViewCircleScrollEventProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewCircleScrollEventProcessor>();
	}
};
static_assert(alignof(UViewCircleScrollEventProcessor) == 0x000008, "Wrong alignment on UViewCircleScrollEventProcessor");
static_assert(sizeof(UViewCircleScrollEventProcessor) == 0x000028, "Wrong size on UViewCircleScrollEventProcessor");

}

