#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MinimapPlugin

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "MinimapPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class MinimapPlugin.MapAreaPrimitiveComponent
// 0x0010 (0x0480 - 0x0470)
class UMapAreaPrimitiveComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_EBE[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaPrimitiveComponent">();
	}
	static class UMapAreaPrimitiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapAreaPrimitiveComponent>();
	}
};
static_assert(alignof(UMapAreaPrimitiveComponent) == 0x000010, "Wrong alignment on UMapAreaPrimitiveComponent");
static_assert(sizeof(UMapAreaPrimitiveComponent) == 0x000480, "Wrong size on UMapAreaPrimitiveComponent");

// Class MinimapPlugin.MapAreaBase
// 0x0018 (0x0250 - 0x0238)
class AMapAreaBase : public AActor
{
public:
	class UBoxComponent*                          AreaBounds;                                        // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapAreaPrimitiveComponent*             AreaPrimitive;                                     // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapViewComponent*                      AreaMapView;                                       // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetMapViewCornerUVs(class UMapViewComponent* MapView, TArray<struct FVector2D>* CornerUVs);

	class UBoxComponent* GetAreaBounds() const;
	int32 GetLevelAtHeight(const float WorldZ) const;
	float GetMapAspectRatio() const;
	class UMapViewComponent* GetMapView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaBase">();
	}
	static class AMapAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapAreaBase>();
	}
};
static_assert(alignof(AMapAreaBase) == 0x000008, "Wrong alignment on AMapAreaBase");
static_assert(sizeof(AMapAreaBase) == 0x000250, "Wrong size on AMapAreaBase");
static_assert(offsetof(AMapAreaBase, AreaBounds) == 0x000238, "Member 'AMapAreaBase::AreaBounds' has a wrong offset!");
static_assert(offsetof(AMapAreaBase, AreaPrimitive) == 0x000240, "Member 'AMapAreaBase::AreaPrimitive' has a wrong offset!");
static_assert(offsetof(AMapAreaBase, AreaMapView) == 0x000248, "Member 'AMapAreaBase::AreaMapView' has a wrong offset!");

// Class MinimapPlugin.MapRevealerComponent
// 0x0060 (0x0500 - 0x04A0)
class UMapRevealerComponent final : public UBoxComponent
{
public:
	class UMaterialInterface*                     RevealMaterial;                                    // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapFogRevealMode                             RevealMode;                                        // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC0[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RevealDropOffDistance;                             // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTempEngineBugWorkaround;                          // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC1[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               RevealMaterialInstance;                            // 0x04B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC2[0x10];                                     // 0x04B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomUnlockAreaInfo>          CustomUnlockAreaInfo;                              // 0x04C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCustomUnlockAreaIndex>         CustomUnlockAreaIdxRule;                           // 0x04D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FString                                 CurActiveFogLevelName;                             // 0x04E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC3[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveCustomAreaFog(const class FString& LevelName);
	void GetCustomAreaFogLevel(const int32 InAreaIndex, class FString* OutLevelName);
	TArray<TSoftObjectPtr<class UTexture2D>> GetLockedAreaFog();
	TArray<TSoftObjectPtr<class UMaterialInterface>> GetLockedBigMapFog();
	TSoftObjectPtr<class UMaterialInterface> GetLockedBigMapFogOpt();
	bool IsLevelNameCfgCustomUnlock(const class FString& LevelName);
	void SetActiveFogLevelName(const class FString& LevelName);
	void SetRevealDropOffDistance(const float NewRevealDropOffDistance);
	void SetRevealExtent(const float NewRevealExtentX, const float NewRevealExtentY);
	void SetRevealMode(const EMapFogRevealMode NewRevealMode);
	void UnlockCustomAreaFog(const class FString& LevelName, int32 InAreaIndex);
	void UnlockCustomAreaFogEx(const class FString& LevelName, const TArray<int32>& InAreaIdxRecord);

	float GetRevealDropOffDistance() const;
	void GetRevealExtent(float* RevealExtentX, float* RevealExtentY) const;
	EMapFogRevealMode GetRevealMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRevealerComponent">();
	}
	static class UMapRevealerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRevealerComponent>();
	}
};
static_assert(alignof(UMapRevealerComponent) == 0x000010, "Wrong alignment on UMapRevealerComponent");
static_assert(sizeof(UMapRevealerComponent) == 0x000500, "Wrong size on UMapRevealerComponent");
static_assert(offsetof(UMapRevealerComponent, RevealMaterial) == 0x000498, "Member 'UMapRevealerComponent::RevealMaterial' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, RevealMode) == 0x0004A0, "Member 'UMapRevealerComponent::RevealMode' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, RevealDropOffDistance) == 0x0004A4, "Member 'UMapRevealerComponent::RevealDropOffDistance' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, bTempEngineBugWorkaround) == 0x0004A8, "Member 'UMapRevealerComponent::bTempEngineBugWorkaround' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, RevealMaterialInstance) == 0x0004B0, "Member 'UMapRevealerComponent::RevealMaterialInstance' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, CustomUnlockAreaInfo) == 0x0004C8, "Member 'UMapRevealerComponent::CustomUnlockAreaInfo' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, CustomUnlockAreaIdxRule) == 0x0004D8, "Member 'UMapRevealerComponent::CustomUnlockAreaIdxRule' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, CurActiveFogLevelName) == 0x0004E8, "Member 'UMapRevealerComponent::CurActiveFogLevelName' has a wrong offset!");

// Class MinimapPlugin.MapBackground
// 0x0148 (0x0398 - 0x0250)
class AMapBackground final : public AMapAreaBase
{
public:
	FMulticastInlineDelegateProperty_             OnMapBackgroundTextureChanged;                     // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundMaterialChanged;                    // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundAppearanceChanged;                  // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundRendered;                           // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundOverlayChanged;                     // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FMapBackgroundLevel>            BackgroundLevels;                                  // 0x02A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BackgroundMaterial_UMG;                            // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BackgroundMaterial_Canvas;                         // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackgroundVisible;                                // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC7[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BackgroundPriority;                                // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BackgroundZOrder;                                  // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DynamicRenderTargetSize;                           // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderNavigationMesh;                             // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC8[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             HiddenActorClasses;                                // 0x02D8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         HiddenActors;                                      // 0x02E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> MaterialInstances;                                 // 0x02F8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UBoxComponent*>                  LevelVisualizers;                                  // 0x0348(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC9[0x4];                                      // 0x0358(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EMapBackgroundType                            BackgroundType;                                    // 0x035C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ECA[0x1B];                                     // 0x035D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMapBackgroundFogMaskChange;                      // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                FieldOfViewSize;                                   // 0x0388(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DynamicOverlaySize;                                // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<struct FMapBackgroundLevel> GetBackgroundLevels();
	class UMaterialInstanceDynamic* GetBackgroundMaterialInstanceForCanvas(class UMapRendererComponent* Renderer);
	void GetBackgroundTextureUVs(class UMapViewComponent* MapViewComp, const TArray<struct FVector2D>& CornerUVs, struct FVector2D* UVOrigin, struct FVector4* UVDir);
	int32 GetIndexInMap(class UMapViewComponent* MapViewComp);
	void InitializeDynamicOverlay(int32 DynamicSize);
	void RefreshJointBackgound(class UMapViewComponent* MapViewComp, const int32 Level);
	void RerenderBackground();
	void SetBackgroundMaterialForCanvas(class UMaterialInterface* NewMaterial);
	void SetBackgroundMaterialForUMG(class UMaterialInterface* NewMaterial);
	void SetBackgroundOverlay(const int32 Level, class UTextureRenderTarget2D* NewBackgroundOverlay);
	void SetBackgroundPriority(const int32 NewBackgroundPriority);
	void SetBackgroundTexture(const int32 Level, class UTexture2D* NewBackgroundTexture);
	void SetBackgroundVisible(const bool bNewVisible);
	void SetBackgroundZOrder(const int32 NewBackgroundZOrder);

	class UMaterialInterface* GetBackgroundMaterialForUMG() const;
	class UTextureRenderTarget2D* GetBackgroundOverlay(const int32 Level) const;
	int32 GetBackgroundPriority() const;
	class UTexture* GetBackgroundTexture(const int32 Level) const;
	class UTexture* GetBackgroundTextureAtHeight(const float WorldZ) const;
	int32 GetBackgroundZOrder() const;
	bool IsBackgroundVisible() const;
	bool IsMultiLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapBackground">();
	}
	static class AMapBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapBackground>();
	}
};
static_assert(alignof(AMapBackground) == 0x000008, "Wrong alignment on AMapBackground");
static_assert(sizeof(AMapBackground) == 0x000398, "Wrong size on AMapBackground");
static_assert(offsetof(AMapBackground, OnMapBackgroundTextureChanged) == 0x000250, "Member 'AMapBackground::OnMapBackgroundTextureChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundMaterialChanged) == 0x000260, "Member 'AMapBackground::OnMapBackgroundMaterialChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundAppearanceChanged) == 0x000270, "Member 'AMapBackground::OnMapBackgroundAppearanceChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundRendered) == 0x000280, "Member 'AMapBackground::OnMapBackgroundRendered' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundOverlayChanged) == 0x000290, "Member 'AMapBackground::OnMapBackgroundOverlayChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundLevels) == 0x0002A0, "Member 'AMapBackground::BackgroundLevels' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundMaterial_UMG) == 0x0002B0, "Member 'AMapBackground::BackgroundMaterial_UMG' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundMaterial_Canvas) == 0x0002B8, "Member 'AMapBackground::BackgroundMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(AMapBackground, bBackgroundVisible) == 0x0002C0, "Member 'AMapBackground::bBackgroundVisible' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundPriority) == 0x0002C4, "Member 'AMapBackground::BackgroundPriority' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundZOrder) == 0x0002C8, "Member 'AMapBackground::BackgroundZOrder' has a wrong offset!");
static_assert(offsetof(AMapBackground, DynamicRenderTargetSize) == 0x0002CC, "Member 'AMapBackground::DynamicRenderTargetSize' has a wrong offset!");
static_assert(offsetof(AMapBackground, bRenderNavigationMesh) == 0x0002D0, "Member 'AMapBackground::bRenderNavigationMesh' has a wrong offset!");
static_assert(offsetof(AMapBackground, HiddenActorClasses) == 0x0002D8, "Member 'AMapBackground::HiddenActorClasses' has a wrong offset!");
static_assert(offsetof(AMapBackground, HiddenActors) == 0x0002E8, "Member 'AMapBackground::HiddenActors' has a wrong offset!");
static_assert(offsetof(AMapBackground, MaterialInstances) == 0x0002F8, "Member 'AMapBackground::MaterialInstances' has a wrong offset!");
static_assert(offsetof(AMapBackground, LevelVisualizers) == 0x000348, "Member 'AMapBackground::LevelVisualizers' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundType) == 0x00035C, "Member 'AMapBackground::BackgroundType' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundFogMaskChange) == 0x000378, "Member 'AMapBackground::OnMapBackgroundFogMaskChange' has a wrong offset!");
static_assert(offsetof(AMapBackground, FieldOfViewSize) == 0x000388, "Member 'AMapBackground::FieldOfViewSize' has a wrong offset!");
static_assert(offsetof(AMapBackground, DynamicOverlaySize) == 0x000394, "Member 'AMapBackground::DynamicOverlaySize' has a wrong offset!");

// Class MinimapPlugin.MapFog
// 0x0180 (0x03D0 - 0x0250)
class AMapFog final : public AMapAreaBase
{
public:
	FMulticastInlineDelegateProperty_             OnMapFogMaterialChanged;                           // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         FogRenderTargetSize;                               // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED2[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FogMaterial_UMG;                                   // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FogMaterial_Canvas;                                // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOpacityHidden;                              // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOpacityExplored;                            // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOpacityRevealing;                           // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED3[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FogCombineMaterial;                                // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FogBackgroundRenderTargetSize;                     // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogCacheLifetime;                                  // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableWorldFog;                                   // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED4[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FogPostProcessMaterial;                            // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOpacityHidden;                                // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOpacityExplored;                              // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOpacityRevealing;                             // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED5[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFogPostProcessVolumeOption                   AutoLocatePostProcessVolume;                       // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED6[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 PermanentRevealRT_A;                               // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 PermanentRevealRT_B;                               // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RevealRT_Staging;                                  // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ED7[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 FogBackground_RT;                                  // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> MaterialInstances;                                 // 0x02F0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FogCombineMatInst;                                 // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FogPostProcessMatInst;                             // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ED8[0x30];                                     // 0x0350(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapRevealerComponent*>          MapRevealers;                                      // 0x0380(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              FogTexture;                                        // 0x0390(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           FogBackgroundColor;                                // 0x03B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMapFogRevealMode                             PlayerRevealMode;                                  // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED9[0x7];                                      // 0x03C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetFogAtLocation(const struct FVector& WorldLocation, const bool bRequireCurrentlyRevealing, float* RevealFactor);
	class UMaterialInterface* GetFogMaterialForUMG();
	class UMaterialInstanceDynamic* GetFogMaterialInstanceForCanvas(class UMapRendererComponent* Renderer);
	void OnMapRevealerRegistered(class UMapRevealerComponent* MapRevealer);
	void OnMapRevealerUnregistered(class UMapRevealerComponent* MapRevealer);
	void ReRenderFogBackground(class UMapRevealerComponent* InMapRevealer);
	void SetFogMaterialForCanvas(class UMaterialInterface* NewMaterial);
	void SetFogMaterialForUMG(class UMaterialInterface* NewMaterial);

	class UTextureRenderTarget2D* GetDestinationFogRenderTarget() const;
	class UTextureRenderTarget2D* GetFogBackgroundRenderTarget() const;
	class UTextureRenderTarget2D* GetSourceFogRenderTarget() const;
	float GetWorldToPixelRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapFog">();
	}
	static class AMapFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapFog>();
	}
};
static_assert(alignof(AMapFog) == 0x000008, "Wrong alignment on AMapFog");
static_assert(sizeof(AMapFog) == 0x0003D0, "Wrong size on AMapFog");
static_assert(offsetof(AMapFog, OnMapFogMaterialChanged) == 0x000250, "Member 'AMapFog::OnMapFogMaterialChanged' has a wrong offset!");
static_assert(offsetof(AMapFog, FogRenderTargetSize) == 0x000260, "Member 'AMapFog::FogRenderTargetSize' has a wrong offset!");
static_assert(offsetof(AMapFog, FogMaterial_UMG) == 0x000268, "Member 'AMapFog::FogMaterial_UMG' has a wrong offset!");
static_assert(offsetof(AMapFog, FogMaterial_Canvas) == 0x000270, "Member 'AMapFog::FogMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(AMapFog, MinimapOpacityHidden) == 0x000278, "Member 'AMapFog::MinimapOpacityHidden' has a wrong offset!");
static_assert(offsetof(AMapFog, MinimapOpacityExplored) == 0x00027C, "Member 'AMapFog::MinimapOpacityExplored' has a wrong offset!");
static_assert(offsetof(AMapFog, MinimapOpacityRevealing) == 0x000280, "Member 'AMapFog::MinimapOpacityRevealing' has a wrong offset!");
static_assert(offsetof(AMapFog, FogCombineMaterial) == 0x000288, "Member 'AMapFog::FogCombineMaterial' has a wrong offset!");
static_assert(offsetof(AMapFog, FogBackgroundRenderTargetSize) == 0x000290, "Member 'AMapFog::FogBackgroundRenderTargetSize' has a wrong offset!");
static_assert(offsetof(AMapFog, FogCacheLifetime) == 0x000294, "Member 'AMapFog::FogCacheLifetime' has a wrong offset!");
static_assert(offsetof(AMapFog, bEnableWorldFog) == 0x000298, "Member 'AMapFog::bEnableWorldFog' has a wrong offset!");
static_assert(offsetof(AMapFog, FogPostProcessMaterial) == 0x0002A0, "Member 'AMapFog::FogPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(AMapFog, WorldOpacityHidden) == 0x0002A8, "Member 'AMapFog::WorldOpacityHidden' has a wrong offset!");
static_assert(offsetof(AMapFog, WorldOpacityExplored) == 0x0002AC, "Member 'AMapFog::WorldOpacityExplored' has a wrong offset!");
static_assert(offsetof(AMapFog, WorldOpacityRevealing) == 0x0002B0, "Member 'AMapFog::WorldOpacityRevealing' has a wrong offset!");
static_assert(offsetof(AMapFog, PostProcessVolume) == 0x0002B8, "Member 'AMapFog::PostProcessVolume' has a wrong offset!");
static_assert(offsetof(AMapFog, AutoLocatePostProcessVolume) == 0x0002C0, "Member 'AMapFog::AutoLocatePostProcessVolume' has a wrong offset!");
static_assert(offsetof(AMapFog, PermanentRevealRT_A) == 0x0002C8, "Member 'AMapFog::PermanentRevealRT_A' has a wrong offset!");
static_assert(offsetof(AMapFog, PermanentRevealRT_B) == 0x0002D0, "Member 'AMapFog::PermanentRevealRT_B' has a wrong offset!");
static_assert(offsetof(AMapFog, RevealRT_Staging) == 0x0002D8, "Member 'AMapFog::RevealRT_Staging' has a wrong offset!");
static_assert(offsetof(AMapFog, FogBackground_RT) == 0x0002E8, "Member 'AMapFog::FogBackground_RT' has a wrong offset!");
static_assert(offsetof(AMapFog, MaterialInstances) == 0x0002F0, "Member 'AMapFog::MaterialInstances' has a wrong offset!");
static_assert(offsetof(AMapFog, FogCombineMatInst) == 0x000340, "Member 'AMapFog::FogCombineMatInst' has a wrong offset!");
static_assert(offsetof(AMapFog, FogPostProcessMatInst) == 0x000348, "Member 'AMapFog::FogPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(AMapFog, MapRevealers) == 0x000380, "Member 'AMapFog::MapRevealers' has a wrong offset!");
static_assert(offsetof(AMapFog, FogTexture) == 0x000390, "Member 'AMapFog::FogTexture' has a wrong offset!");
static_assert(offsetof(AMapFog, FogBackgroundColor) == 0x0003B8, "Member 'AMapFog::FogBackgroundColor' has a wrong offset!");
static_assert(offsetof(AMapFog, PlayerRevealMode) == 0x0003C8, "Member 'AMapFog::PlayerRevealMode' has a wrong offset!");

// Class MinimapPlugin.MapFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMapFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMapIconComponent*> BoxSelectInView(const struct FVector2D& StartUV, const struct FVector2D& EndUV, class UMapViewComponent* MapView, const bool bIsCircular);
	static struct FVector2D ClampIntoView(const struct FVector2D& UV, const float OuterRadiusUV, const bool bIsCircular);
	static struct FVector2D ClampIntoViewEx(const struct FVector2D& UV, const float OuterRadiusUV, const bool bIsCircular, const bool bIsMinimap, const struct FVector2D& UVOffset);
	static bool ComputeViewFrustum(const class UObject* WorldContextObject, class UMapViewComponent* MapView, const bool bIsCircular, TArray<struct FVector2D>* CornerUVs, const float FloorDistance);
	static bool DetectIsInView(const struct FVector2D& UV, const struct FVector2D& OuterRadiusUV, const bool bIsCircular);
	static bool DetectIsInViewEx(const struct FVector2D& UV, const struct FVector2D& OuterRadiusUV, const bool bIsCircular, const bool bIsMinimap, const struct FVector2D& UVOffset);
	static class UMapViewComponent* FindMapView(class UObject* WorldContextObject, const EMapViewSearchOption MapViewSearchOption);
	static class AMapBackground* GetFirstMapBackground(const class UObject* WorldContextObject);
	static class UMapTrackerComponent* GetMapTracker(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapFunctionLibrary">();
	}
	static class UMapFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapFunctionLibrary>();
	}
};
static_assert(alignof(UMapFunctionLibrary) == 0x000008, "Wrong alignment on UMapFunctionLibrary");
static_assert(sizeof(UMapFunctionLibrary) == 0x000028, "Wrong size on UMapFunctionLibrary");

// Class MinimapPlugin.MapIconComponent
// 0x02E0 (0x0770 - 0x0490)
class UMapIconComponent final : public UBillboardComponent
{
public:
	FMulticastInlineDelegateProperty_             OnIconAppearanceChanged;                           // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconMaterialChanged;                             // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconMaterialInstancesChanged;                    // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconEnteredView;                                 // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconLeftView;                                    // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconDestroyed;                                   // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconHoverStart;                                  // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconHoverEnd;                                    // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconClicked;                                     // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   IconCategory;                                      // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             IconTexture;                                       // 0x0528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     IconMaterial_UMG;                                  // 0x0530(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     IconMaterial_Canvas;                               // 0x0538(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconVisible;                                      // 0x0540(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconRotates;                                      // 0x0541(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIconSizeUnit                                 IconSizeUnit;                                      // 0x0542(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE5[0x1];                                      // 0x0543(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconSize;                                          // 0x0544(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconDrawColor;                                     // 0x0548(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IconZOrder;                                        // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObjectiveArrowEnabled;                            // 0x055C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE6[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ObjectiveArrowTexture;                             // 0x0560(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ObjectiveArrowMaterial_UMG;                        // 0x0568(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ObjectiveArrowMaterial_Canvas;                     // 0x0570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObjectiveArrowRotates;                            // 0x0578(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE7[0x3];                                      // 0x0579(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObjectiveArrowSize;                                // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconInteractable;                                 // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE8[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IconTooltipText;                                   // 0x0584(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIconBackgroundInteraction                    IconBackgroundInteraction;                         // 0x058C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIconFogInteraction                           IconFogInteraction;                                // 0x058D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE9[0x2];                                      // 0x058E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconFogRevealThreshold;                            // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideOwnerInsideFog;                               // 0x0594(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EEA[0x3];                                      // 0x0595(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMapViewComponent*, bool>          IsRenderedPerView;                                 // 0x0598(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     InitialIconMaterial_UMG;                           // 0x05E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     InitialIconMaterial_Canvas;                        // 0x05F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UUserWidget*, class UMaterialInstanceDynamic*> IconMaterialInstances_UMG;                         // 0x05F8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> IconMaterialInstances_Canvas;                      // 0x0648(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> ObjectiveArrowMaterialInstances_Canvas;            // 0x0698(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EEB[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconRotateOffset;                                  // 0x06F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              IconPovit;                                         // 0x06F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   IconPOIName;                                       // 0x06FC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EEC[0x4];                                      // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                MapIconParticle;                                   // 0x0708(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              IconParticleSize;                                  // 0x0710(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              IconParticleMinimapSize;                           // 0x0718(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            VisibleZoomRange;                                  // 0x0720(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RotateWithPlayerCamera;                            // 0x0730(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          OnlyLocalClientSee;                                // 0x0731(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EED[0x2];                                      // 0x0732(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconMinimapSize;                                   // 0x0734(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EEE[0x4];                                      // 0x0738(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PointID;                                           // 0x073C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EEF[0x24];                                     // 0x0744(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInEdit;                                         // 0x0768(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF0[0x7];                                      // 0x0769(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetIconMaterialInstancesForCanvas(TArray<class UMaterialInstanceDynamic*>* MaterialInstances);
	void GetIconMaterialInstancesForUMG(TArray<class UMaterialInstanceDynamic*>* MaterialInstances);
	bool MarkRenderedInView(class UMapViewComponent* View, const bool bNewIsRendered);
	void ReceiveClicked(const bool bIsLeftMouseButton);
	void ReceiveHoverEnd();
	void ReceiveHoverStart();
	void RegisterMaterialInstanceFromUMG(class UUserWidget* IconWidget, class UMaterialInstanceDynamic* MatInst);
	void ResetIconMaterialForCanvas();
	void ResetIconMaterialForUMG();
	void SetIconBackgroundInteraction(const EIconBackgroundInteraction NewBackgroundInteraction);
	void SetIconDrawColor(const struct FLinearColor& NewDrawColor);
	void SetIconFogInteraction(const EIconFogInteraction NewFogInteraction);
	void SetIconFogRevealThreshold(const float NewFogRevealThreshold);
	void SetIconInteractable(const bool bNewInteractable);
	void SetIconMaterialForCanvas(class UMaterialInterface* NewMaterial);
	void SetIconMaterialForUMG(class UMaterialInterface* NewMaterial);
	void SetIconParticle(TSoftObjectPtr<class UObject> IconParticle, const struct FVector2D& ParticleSize, const struct FVector2D& MinimapParticleSize);
	void SetIconPOIName(class FName POIName);
	void SetIconRotateOffset(const float RotateOffset);
	void SetIconRotates(const bool bNewRotates);
	void SetIconSize(const float NewIconSize, const EIconSizeUnit NewIconSizeUnit);
	void SetIconTexture(class UTexture2D* NewIcon);
	void SetIconTooltipText(class FName NewIconName);
	void SetIconVisible(const bool bNewVisible, bool bIsUpdateLocation);
	void SetIconZOrder(const int32 NewZOrder);
	void SetObjectiveArrowEnabled(const bool bNewObjectiveArrowEnabled);
	void SetObjectiveArrowRotates(const bool bNewRotates);
	void SetObjectiveArrowSize(const float NewObjectiveArrowSize);
	void SetObjectiveArrowTexture(class UTexture2D* NewTexture);

	bool DoesIconRotate() const;
	bool DoesObjectiveArrowRotate() const;
	EIconBackgroundInteraction GetIconBackgroundInteraction() const;
	struct FLinearColor GetIconDrawColor() const;
	EIconFogInteraction GetIconFogInteraction() const;
	float GetIconFogRevealThreshold() const;
	class UMaterialInterface* GetIconMaterialForCanvas() const;
	class UMaterialInterface* GetIconMaterialForUMG() const;
	class UObject* GetIconParticle() const;
	struct FVector2D GetIconParticleSize(bool bIsMinimap) const;
	class FName GetIconPOIName() const;
	struct FVector2D GetIconPovit() const;
	float GetIconRotateOffset() const;
	float GetIconSize() const;
	float GetIconSizeEx(bool bIsMinimap) const;
	EIconSizeUnit GetIconSizeUnit() const;
	class UTexture2D* GetIconTexture() const;
	class FName GetIconTooltipText() const;
	int32 GetIconZOrder() const;
	class UMaterialInterface* GetObjectiveArrowMaterialForCanvas() const;
	class UMaterialInterface* GetObjectiveArrowMaterialForUMG() const;
	float GetObjectiveArrowSize() const;
	class UTexture2D* GetObjectiveArrowTexture() const;
	bool GetOnlyLocalClientSee() const;
	bool GetRotateWithPlayerCamera() const;
	bool IsIconInteractable() const;
	bool IsIconVisible() const;
	bool IsObjectiveArrowEnabled() const;
	bool IsRenderedInView(class UMapViewComponent* View) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconComponent">();
	}
	static class UMapIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapIconComponent>();
	}
};
static_assert(alignof(UMapIconComponent) == 0x000010, "Wrong alignment on UMapIconComponent");
static_assert(sizeof(UMapIconComponent) == 0x000770, "Wrong size on UMapIconComponent");
static_assert(offsetof(UMapIconComponent, OnIconAppearanceChanged) == 0x000490, "Member 'UMapIconComponent::OnIconAppearanceChanged' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconMaterialChanged) == 0x0004A0, "Member 'UMapIconComponent::OnIconMaterialChanged' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconMaterialInstancesChanged) == 0x0004B0, "Member 'UMapIconComponent::OnIconMaterialInstancesChanged' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconEnteredView) == 0x0004C0, "Member 'UMapIconComponent::OnIconEnteredView' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconLeftView) == 0x0004D0, "Member 'UMapIconComponent::OnIconLeftView' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconDestroyed) == 0x0004E0, "Member 'UMapIconComponent::OnIconDestroyed' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconHoverStart) == 0x0004F0, "Member 'UMapIconComponent::OnIconHoverStart' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconHoverEnd) == 0x000500, "Member 'UMapIconComponent::OnIconHoverEnd' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconClicked) == 0x000510, "Member 'UMapIconComponent::OnIconClicked' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconCategory) == 0x000520, "Member 'UMapIconComponent::IconCategory' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconTexture) == 0x000528, "Member 'UMapIconComponent::IconTexture' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterial_UMG) == 0x000530, "Member 'UMapIconComponent::IconMaterial_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterial_Canvas) == 0x000538, "Member 'UMapIconComponent::IconMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIconVisible) == 0x000540, "Member 'UMapIconComponent::bIconVisible' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIconRotates) == 0x000541, "Member 'UMapIconComponent::bIconRotates' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconSizeUnit) == 0x000542, "Member 'UMapIconComponent::IconSizeUnit' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconSize) == 0x000544, "Member 'UMapIconComponent::IconSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconDrawColor) == 0x000548, "Member 'UMapIconComponent::IconDrawColor' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconZOrder) == 0x000558, "Member 'UMapIconComponent::IconZOrder' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bObjectiveArrowEnabled) == 0x00055C, "Member 'UMapIconComponent::bObjectiveArrowEnabled' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowTexture) == 0x000560, "Member 'UMapIconComponent::ObjectiveArrowTexture' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowMaterial_UMG) == 0x000568, "Member 'UMapIconComponent::ObjectiveArrowMaterial_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowMaterial_Canvas) == 0x000570, "Member 'UMapIconComponent::ObjectiveArrowMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bObjectiveArrowRotates) == 0x000578, "Member 'UMapIconComponent::bObjectiveArrowRotates' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowSize) == 0x00057C, "Member 'UMapIconComponent::ObjectiveArrowSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIconInteractable) == 0x000580, "Member 'UMapIconComponent::bIconInteractable' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconTooltipText) == 0x000584, "Member 'UMapIconComponent::IconTooltipText' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconBackgroundInteraction) == 0x00058C, "Member 'UMapIconComponent::IconBackgroundInteraction' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconFogInteraction) == 0x00058D, "Member 'UMapIconComponent::IconFogInteraction' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconFogRevealThreshold) == 0x000590, "Member 'UMapIconComponent::IconFogRevealThreshold' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bHideOwnerInsideFog) == 0x000594, "Member 'UMapIconComponent::bHideOwnerInsideFog' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IsRenderedPerView) == 0x000598, "Member 'UMapIconComponent::IsRenderedPerView' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, InitialIconMaterial_UMG) == 0x0005E8, "Member 'UMapIconComponent::InitialIconMaterial_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, InitialIconMaterial_Canvas) == 0x0005F0, "Member 'UMapIconComponent::InitialIconMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterialInstances_UMG) == 0x0005F8, "Member 'UMapIconComponent::IconMaterialInstances_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterialInstances_Canvas) == 0x000648, "Member 'UMapIconComponent::IconMaterialInstances_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowMaterialInstances_Canvas) == 0x000698, "Member 'UMapIconComponent::ObjectiveArrowMaterialInstances_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconRotateOffset) == 0x0006F0, "Member 'UMapIconComponent::IconRotateOffset' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconPovit) == 0x0006F4, "Member 'UMapIconComponent::IconPovit' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconPOIName) == 0x0006FC, "Member 'UMapIconComponent::IconPOIName' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, MapIconParticle) == 0x000708, "Member 'UMapIconComponent::MapIconParticle' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconParticleSize) == 0x000710, "Member 'UMapIconComponent::IconParticleSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconParticleMinimapSize) == 0x000718, "Member 'UMapIconComponent::IconParticleMinimapSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, VisibleZoomRange) == 0x000720, "Member 'UMapIconComponent::VisibleZoomRange' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, RotateWithPlayerCamera) == 0x000730, "Member 'UMapIconComponent::RotateWithPlayerCamera' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnlyLocalClientSee) == 0x000731, "Member 'UMapIconComponent::OnlyLocalClientSee' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMinimapSize) == 0x000734, "Member 'UMapIconComponent::IconMinimapSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, PointID) == 0x00073C, "Member 'UMapIconComponent::PointID' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIsInEdit) == 0x000768, "Member 'UMapIconComponent::bIsInEdit' has a wrong offset!");

// Class MinimapPlugin.MapRendererComponent
// 0x00E0 (0x0198 - 0x00B8)
class UMapRendererComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMapClicked;                                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMapViewSearchOption                          AutoLocateMapView;                                 // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCircular;                                       // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRendered;                                       // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawFrustum;                                      // 0x00CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrustumFloorDistance;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundFillColor;                               // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF6[0x2];                                      // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Margin;                                            // 0x00E4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Size;                                              // 0x00F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF7[0x4];                                      // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FillMaterial;                                      // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               FillMaterialInstance;                              // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapTrackerComponent*                   MapTracker;                                        // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapViewComponent*                      MapView;                                           // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UMapIconComponent*>                HoveringIcons;                                     // 0x0120(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMapIconComponent*>              BufferedHoverStartEvents;                          // 0x0170(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMapIconComponent*>              BufferedHoverEndEvents;                            // 0x0180(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvas*                                LastCanvas;                                        // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetAutoLocateMapView(const EMapViewSearchOption InAutoLocateMapView);
	void SetBackgroundFillColor(const struct FLinearColor& NewBackgroundFillColor);
	void SetDrawFrustum(const bool bNewDrawFrustum);
	void SetFrustumFloorDistance(const float NewFrustumFloorDistance);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetIsCircular(const bool bNewIsCircular);
	void SetIsRendered(const bool bNewIsRendered);
	void SetMapView(class UMapViewComponent* InMapView);
	void SetMargin(const int32 Left, const int32 Top, const int32 Right, const int32 Bottom);
	void SetSize(const int32 Width, const int32 Height);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

	struct FLinearColor GetBackgroundFillColor() const;
	bool GetDrawFrustum() const;
	float GetFrustumFloorDistance() const;
	bool IsCircular() const;
	bool IsRendered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRendererComponent">();
	}
	static class UMapRendererComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRendererComponent>();
	}
};
static_assert(alignof(UMapRendererComponent) == 0x000008, "Wrong alignment on UMapRendererComponent");
static_assert(sizeof(UMapRendererComponent) == 0x000198, "Wrong size on UMapRendererComponent");
static_assert(offsetof(UMapRendererComponent, OnMapClicked) == 0x0000B8, "Member 'UMapRendererComponent::OnMapClicked' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, AutoLocateMapView) == 0x0000C8, "Member 'UMapRendererComponent::AutoLocateMapView' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, bIsCircular) == 0x0000C9, "Member 'UMapRendererComponent::bIsCircular' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, bIsRendered) == 0x0000CA, "Member 'UMapRendererComponent::bIsRendered' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, bDrawFrustum) == 0x0000CB, "Member 'UMapRendererComponent::bDrawFrustum' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, FrustumFloorDistance) == 0x0000CC, "Member 'UMapRendererComponent::FrustumFloorDistance' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, BackgroundFillColor) == 0x0000D0, "Member 'UMapRendererComponent::BackgroundFillColor' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, HorizontalAlignment) == 0x0000E0, "Member 'UMapRendererComponent::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, VerticalAlignment) == 0x0000E1, "Member 'UMapRendererComponent::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, Margin) == 0x0000E4, "Member 'UMapRendererComponent::Margin' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, Size) == 0x0000F4, "Member 'UMapRendererComponent::Size' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, FillMaterial) == 0x000100, "Member 'UMapRendererComponent::FillMaterial' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, FillMaterialInstance) == 0x000108, "Member 'UMapRendererComponent::FillMaterialInstance' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, MapTracker) == 0x000110, "Member 'UMapRendererComponent::MapTracker' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, MapView) == 0x000118, "Member 'UMapRendererComponent::MapView' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, HoveringIcons) == 0x000120, "Member 'UMapRendererComponent::HoveringIcons' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, BufferedHoverStartEvents) == 0x000170, "Member 'UMapRendererComponent::BufferedHoverStartEvents' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, BufferedHoverEndEvents) == 0x000180, "Member 'UMapRendererComponent::BufferedHoverEndEvents' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, LastCanvas) == 0x000190, "Member 'UMapRendererComponent::LastCanvas' has a wrong offset!");

// Class MinimapPlugin.MapTrackerComponent
// 0x00C0 (0x0178 - 0x00B8)
class UMapTrackerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMapIconRegistered;                               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapIconUnregistered;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundRegistered;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundUnregistered;                       // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapFogRegistered;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapFogUnregistered;                              // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapRevealerRegistered;                           // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapRevealerUnregistered;                         // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMapIconComponent*>              MapIcons;                                          // 0x0138(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AMapBackground*>                 MapBackgrounds;                                    // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMapFog*>                        MapFogs;                                           // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMapRevealerComponent*>          MapRevealers;                                      // 0x0168(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	float GetFogRevealedFactor(const struct FVector& WorldLocation, const bool bRequireCurrentlyRevealing, bool* bIsInsideFogVolume) const;
	const TArray<class AMapBackground*> GetMapBackgrounds() const;
	const TArray<class AMapFog*> GetMapFogs() const;
	const TArray<class UMapIconComponent*> GetMapIcons() const;
	const TArray<class UMapRevealerComponent*> GetMapRevealers() const;
	bool HasMapFog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTrackerComponent">();
	}
	static class UMapTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapTrackerComponent>();
	}
};
static_assert(alignof(UMapTrackerComponent) == 0x000008, "Wrong alignment on UMapTrackerComponent");
static_assert(sizeof(UMapTrackerComponent) == 0x000178, "Wrong size on UMapTrackerComponent");
static_assert(offsetof(UMapTrackerComponent, OnMapIconRegistered) == 0x0000B8, "Member 'UMapTrackerComponent::OnMapIconRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapIconUnregistered) == 0x0000C8, "Member 'UMapTrackerComponent::OnMapIconUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapBackgroundRegistered) == 0x0000D8, "Member 'UMapTrackerComponent::OnMapBackgroundRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapBackgroundUnregistered) == 0x0000E8, "Member 'UMapTrackerComponent::OnMapBackgroundUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapFogRegistered) == 0x0000F8, "Member 'UMapTrackerComponent::OnMapFogRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapFogUnregistered) == 0x000108, "Member 'UMapTrackerComponent::OnMapFogUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapRevealerRegistered) == 0x000118, "Member 'UMapTrackerComponent::OnMapRevealerRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapRevealerUnregistered) == 0x000128, "Member 'UMapTrackerComponent::OnMapRevealerUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapIcons) == 0x000138, "Member 'UMapTrackerComponent::MapIcons' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapBackgrounds) == 0x000148, "Member 'UMapTrackerComponent::MapBackgrounds' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapFogs) == 0x000158, "Member 'UMapTrackerComponent::MapFogs' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapRevealers) == 0x000168, "Member 'UMapTrackerComponent::MapRevealers' has a wrong offset!");

// Class MinimapPlugin.MapViewComponent
// 0x01F0 (0x0690 - 0x04A0)
class UMapViewComponent final : public UBoxComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVisibleCategoriesChanged;                        // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewSizeChanged;                                 // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewDestroyed;                                   // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMapViewRotationMode                          RotationMode;                                      // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF9[0x3];                                      // 0x04C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedRotation;                                     // 0x04CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InheritedYawOffset;                                // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportZooming;                                   // 0x04DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFA[0x3];                                      // 0x04DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HeightProxy;                                       // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackgoundLevelCacheLifetime;                       // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFB[0xAC];                                     // 0x04EC(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AMapBackground*>                   MapBackgrounds;                                    // 0x0598(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AMapBackground*, int32>            PositionOnMultiLevelBackgrounds;                   // 0x05E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EFC[0x50];                                     // 0x0638(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimapZoom;                                       // 0x0688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFD[0x4];                                      // 0x068C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeprojectViewToWorld(const float U, const float V, struct FVector* WorldPos);
	int32 GetActiveBackgroundLevel(const class AMapBackground* MapBackground);
	int32 GetActiveBackgroundPriority(bool* IsInsideAnyBackground);
	bool GetViewCoordinates(const struct FVector& WorldPos, bool bForceRectangular, float* U, float* V);
	void GetViewYaw(const float WorldYaw, float* Yaw);
	TArray<struct FVector> GetWorldCorners();
	bool IsSameBackgroundLevel(const class UMapIconComponent* MapIcon);
	void RegisterMultiLevelMapBackground(class AMapBackground* MapBackground);
	void SetIconCategoryVisible(class FName IconCategory, const bool bNewVisible);
	void SetViewExtent(const float NewViewExtentX, const float NewViewExtentY);
	void SetZoomScale(const float NewZoomScale);
	void UnregisterMultiLevelMapBackground(class AMapBackground* MapBackground);

	float GetMinimapZoom() const;
	float GetViewAspectRatio() const;
	void GetViewExtent(float* ViewExtentX, float* ViewExtentY) const;
	float GetZoomScale() const;
	bool IsIconCategoryVisible(class FName IconCategory) const;
	bool ViewContains(const struct FVector& WorldPos, const float WorldRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapViewComponent">();
	}
	static class UMapViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapViewComponent>();
	}
};
static_assert(alignof(UMapViewComponent) == 0x000010, "Wrong alignment on UMapViewComponent");
static_assert(sizeof(UMapViewComponent) == 0x000690, "Wrong size on UMapViewComponent");
static_assert(offsetof(UMapViewComponent, OnVisibleCategoriesChanged) == 0x000498, "Member 'UMapViewComponent::OnVisibleCategoriesChanged' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, OnViewSizeChanged) == 0x0004A8, "Member 'UMapViewComponent::OnViewSizeChanged' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, OnViewDestroyed) == 0x0004B8, "Member 'UMapViewComponent::OnViewDestroyed' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, RotationMode) == 0x0004C8, "Member 'UMapViewComponent::RotationMode' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, FixedRotation) == 0x0004CC, "Member 'UMapViewComponent::FixedRotation' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, InheritedYawOffset) == 0x0004D8, "Member 'UMapViewComponent::InheritedYawOffset' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, bSupportZooming) == 0x0004DC, "Member 'UMapViewComponent::bSupportZooming' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, HeightProxy) == 0x0004E0, "Member 'UMapViewComponent::HeightProxy' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, BackgoundLevelCacheLifetime) == 0x0004E8, "Member 'UMapViewComponent::BackgoundLevelCacheLifetime' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, MapBackgrounds) == 0x000598, "Member 'UMapViewComponent::MapBackgrounds' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, PositionOnMultiLevelBackgrounds) == 0x0005E8, "Member 'UMapViewComponent::PositionOnMultiLevelBackgrounds' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, MinimapZoom) == 0x000688, "Member 'UMapViewComponent::MinimapZoom' has a wrong offset!");

}

