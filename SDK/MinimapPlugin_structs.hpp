#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MinimapPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum MinimapPlugin.EMapViewRotationMode
// NumValues: 0x0003
enum class EMapViewRotationMode : uint8
{
	UseFixedRotation                         = 0,
	InheritYaw                               = 1,
	EMapViewRotationMode_MAX                 = 2,
};

// Enum MinimapPlugin.EFogPostProcessVolumeOption
// NumValues: 0x0004
enum class EFogPostProcessVolumeOption : uint8
{
	AutoLocate                               = 0,
	AutoLocateOrCreate                       = 1,
	Manual                                   = 2,
	EFogPostProcessVolumeOption_MAX          = 3,
};

// Enum MinimapPlugin.EMapViewSearchOption
// NumValues: 0x0006
enum class EMapViewSearchOption : uint8
{
	Any                                      = 0,
	OnPlayer                                 = 1,
	OnMapBackground                          = 2,
	OnMapFog                                 = 3,
	Disabled                                 = 4,
	EMapViewSearchOption_MAX                 = 5,
};

// Enum MinimapPlugin.EIconBackgroundInteraction
// NumValues: 0x0006
enum class EIconBackgroundInteraction : uint8
{
	AlwaysRender                             = 0,
	OnlyRenderInSameVolume                   = 1,
	OnlyRenderOnSameFloor                    = 2,
	OnlyRenderInPriorityVolume               = 3,
	OnlyRenderOnPriorityFloor                = 4,
	EIconBackgroundInteraction_MAX           = 5,
};

// Enum MinimapPlugin.EIconFogInteraction
// NumValues: 0x0005
enum class EIconFogInteraction : uint8
{
	OnlyRenderWhenRevealing                  = 0,
	OnlyRenderWhenExplored                   = 1,
	AlwaysRenderUnderFog                     = 2,
	AlwaysRenderAboveFog                     = 3,
	EIconFogInteraction_MAX                  = 4,
};

// Enum MinimapPlugin.EMapBackgroundType
// NumValues: 0x0003
enum class EMapBackgroundType : uint8
{
	Source                                   = 0,
	Custom                                   = 1,
	EMapBackgroundType_MAX                   = 2,
};

// Enum MinimapPlugin.EMapFogRevealMode
// NumValues: 0x0005
enum class EMapFogRevealMode : uint8
{
	Off                                      = 0,
	Temporary                                = 1,
	Permanent                                = 2,
	CustomUnlockArea                         = 3,
	EMapFogRevealMode_MAX                    = 4,
};

// Enum MinimapPlugin.EIconSizeUnit
// NumValues: 0x0003
enum class EIconSizeUnit : uint8
{
	ScreenSpace                              = 0,
	WorldSpace                               = 1,
	EIconSizeUnit_MAX                        = 2,
};

// ScriptStruct MinimapPlugin.MapBackgroundLevel
// 0x0060 (0x0060 - 0x0000)
struct FMapBackgroundLevel final
{
public:
	class UTexture2D*                             BackgroundTexture;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 Overlay;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelHeight;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SamplingResolution;                                // 0x001C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EBD[0x2C];                                     // 0x0024(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTextureRenderTarget2D*>         DiscardMapRenderTargetList;                        // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapBackgroundLevel) == 0x000008, "Wrong alignment on FMapBackgroundLevel");
static_assert(sizeof(FMapBackgroundLevel) == 0x000060, "Wrong size on FMapBackgroundLevel");
static_assert(offsetof(FMapBackgroundLevel, BackgroundTexture) == 0x000000, "Member 'FMapBackgroundLevel::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(FMapBackgroundLevel, RenderTarget) == 0x000008, "Member 'FMapBackgroundLevel::RenderTarget' has a wrong offset!");
static_assert(offsetof(FMapBackgroundLevel, Overlay) == 0x000010, "Member 'FMapBackgroundLevel::Overlay' has a wrong offset!");
static_assert(offsetof(FMapBackgroundLevel, LevelHeight) == 0x000018, "Member 'FMapBackgroundLevel::LevelHeight' has a wrong offset!");
static_assert(offsetof(FMapBackgroundLevel, SamplingResolution) == 0x00001C, "Member 'FMapBackgroundLevel::SamplingResolution' has a wrong offset!");
static_assert(offsetof(FMapBackgroundLevel, DiscardMapRenderTargetList) == 0x000050, "Member 'FMapBackgroundLevel::DiscardMapRenderTargetList' has a wrong offset!");

// ScriptStruct MinimapPlugin.CustomUnlockAreaIndex
// 0x0018 (0x0018 - 0x0000)
struct FCustomUnlockAreaIndex final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinIndex;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIndex;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomUnlockAreaIndex) == 0x000008, "Wrong alignment on FCustomUnlockAreaIndex");
static_assert(sizeof(FCustomUnlockAreaIndex) == 0x000018, "Wrong size on FCustomUnlockAreaIndex");
static_assert(offsetof(FCustomUnlockAreaIndex, LevelName) == 0x000000, "Member 'FCustomUnlockAreaIndex::LevelName' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaIndex, MinIndex) == 0x000010, "Member 'FCustomUnlockAreaIndex::MinIndex' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaIndex, MaxIndex) == 0x000014, "Member 'FCustomUnlockAreaIndex::MaxIndex' has a wrong offset!");

// ScriptStruct MinimapPlugin.CustomUnlockAreaFog
// 0x0090 (0x0090 - 0x0000)
struct FCustomUnlockAreaFog final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      BigMapFogMatInst;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              FogTexture;                                        // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UnlockEffectMapTexture;                            // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnlockEffectMapZoom;                               // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UnlockEffectMapOrigin;                             // 0x007C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UnlockEffectOffset;                                // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomUnlockAreaFog) == 0x000008, "Wrong alignment on FCustomUnlockAreaFog");
static_assert(sizeof(FCustomUnlockAreaFog) == 0x000090, "Wrong size on FCustomUnlockAreaFog");
static_assert(offsetof(FCustomUnlockAreaFog, BigMapFogMatInst) == 0x000000, "Member 'FCustomUnlockAreaFog::BigMapFogMatInst' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaFog, FogTexture) == 0x000028, "Member 'FCustomUnlockAreaFog::FogTexture' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaFog, UnlockEffectMapTexture) == 0x000050, "Member 'FCustomUnlockAreaFog::UnlockEffectMapTexture' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaFog, UnlockEffectMapZoom) == 0x000078, "Member 'FCustomUnlockAreaFog::UnlockEffectMapZoom' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaFog, UnlockEffectMapOrigin) == 0x00007C, "Member 'FCustomUnlockAreaFog::UnlockEffectMapOrigin' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaFog, UnlockEffectOffset) == 0x000088, "Member 'FCustomUnlockAreaFog::UnlockEffectOffset' has a wrong offset!");

// ScriptStruct MinimapPlugin.CustomUnlockAreaInfo
// 0x0058 (0x0058 - 0x0000)
struct FCustomUnlockAreaInfo final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 HasUnlockIndex;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      MapFogMatInst;                                     // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomUnlockAreaFog>           UnlockAreaFog;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomUnlockAreaInfo) == 0x000008, "Wrong alignment on FCustomUnlockAreaInfo");
static_assert(sizeof(FCustomUnlockAreaInfo) == 0x000058, "Wrong size on FCustomUnlockAreaInfo");
static_assert(offsetof(FCustomUnlockAreaInfo, LevelName) == 0x000000, "Member 'FCustomUnlockAreaInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaInfo, HasUnlockIndex) == 0x000010, "Member 'FCustomUnlockAreaInfo::HasUnlockIndex' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaInfo, MapFogMatInst) == 0x000020, "Member 'FCustomUnlockAreaInfo::MapFogMatInst' has a wrong offset!");
static_assert(offsetof(FCustomUnlockAreaInfo, UnlockAreaFog) == 0x000048, "Member 'FCustomUnlockAreaInfo::UnlockAreaFog' has a wrong offset!");

}

